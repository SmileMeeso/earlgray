//스크립트 시작마다 cache, trigger 목록 열기
var _cache = CacheService.getScriptCache();
var _triggers = ScriptApp.getProjectTriggers();

var _logSheet = SpreadsheetApp.openByUrl('https://docs.google.com/spreadsheets/d/1XPPyuxUnrxsprzTZ5-Yqm8NYHnGyPEthAYVcFSU5MBw/edit#gid=0').getSheetByName('LOG'); //로그를 담을 시트

function main() {
  var timestamp = getTime('NUMBER'); //트리거 시작 시간
  systemLog('main 함수를 시작합니다.');
  
  //최초 실행인 경우(자동 설정된 트리거 외에 다른 트리거가 없을 경우) IndexHandler부터 시작
  try{
    var thisTrigger = _triggers[1].getHandlerFunction();
  }catch(e){
    var thisTrigger = 'IndexHandler';
  }
  //트리거 function 이름 가져오기
  
  //*트리거 이름에 따라서 분기
  
  /************************** Index 생성 **************************/
  if(thisTrigger == 'IndexHandler'){
    IndexHandler();
  }
  
  /************************** Spreadsheet 검사 **************************/
  
  /************************** QA Analysis **************************/
}

/******************** page_id 리스트 가져오기 ********************/
//page_id 리스트에서 스프레드시트 목록과 POC를 가져옴
//리턴값은 [정의서 링크, 정의서 제목, 정의서 POC] 2차원 배열
function readSpreadsheetList(listURL){
  var spreadsheet = SpreadsheetApp.openByUrl(listURL);
  var sheet =  spreadsheet.getSheetByName('모바일/PC v.3.0 (BETA)');
  var content = sheet.getRange("F3:H").getValues();
  
  systemLog('총 ' + content.length + '개의 정의서를 가져왔습니다.');
  
  return content; //정의서 리스트 배열 리턴
}

/******************** 키워드를 통해 정의서를 가져오기 ********************/
//..........해당 스프레드 시트를 열어 정보를 가져온다
function searchSpreadsheet(spreadsheetURL){
  var targetSpreadsheetURL = spreadsheetURL;
}

/******************** Insert 관련 함수 ********************/
//..........스프레드시트에 배열 입력하기
//..........sheetName 시트가 없는 경우 시트를 새로 생성
function dumpSpreadsheet(spreadsheetURL, sheetName, Array, isError){
  var targetSpreadsheetURL = spreadsheetURL;
  var targetSheetName = sheetName;
  var arrayForDump = Array;
  var arrayForDumpLength = Array.length;

  if(arrayForDumpLength != 0){
    var targetSpreadsheet = SpreadsheetApp.openByUrl(targetSpreadsheetURL);
    
    //오늘자 시트가 없는 경우 시트를 새로 생성
    var targetSheet = targetSpreadsheet.getSheetByName(sheetName);
    
    if(!targetSheet){
      var sheetTemplate = targetSpreadsheet.getSheetByName('template');
      var targetSheet = targetSpreadsheet.insertSheet(targetSheetName, 1, {template : sheetTemplate});
    }
    //오늘자 시트가 있는 경우 구분자 생성......
    
    var targetSheetStartCol = targetSheet.getLastColumn();
    var targetSheetStartRow = targetSheet.getLastRow();
    var targetSheetLastCol = targetSheet.getLastColumn();
    
    //열 추가
    //추가할 index 갯수만큼  추가
    try{
      targetSheet.insertRows(targetSheetStartRow + 1, arrayForDumpLength);
      var targetSheetLastRow = targetSheetStartRow + arrayForDumpLength;
    }catch(e){
      systemLog(e + " //추가하려던 열 갯수 : " + arrayForDumpLength);
    }
    
    //범위를 잡은 후 dump
    try{
      targetSheet.getRange(targetSheetStartRow + 1, 1, arrayForDumpLength, targetSheetLastCol).setValues(arrayForDump);
      targetSheet.getRange(1, 2).setValues([[getTime('SEPARATE')]]);
      systemLog('Dump가 완료되었습니다.');
    }catch(e){
      systemLog(e);
    }
  }
}
/******************** trigger ********************/
function setTrigger(functionName, minute){
  ScriptApp.newTrigger(functionName)
        .timeBased()
        .after(minute * 60 * 1000)
        .create();
}

/******************** cache  ********************/
//..........cache 넣기
function setArrayCache(array, cacheKey){
  var cacheArray = JSON.stringify(array);
  
  if(!_cache.get(cacheKey)){
    _cache.put(cacheKey, cacheArray);
  }else if(_cache.get(cacheKey)){
    _cache.remove(cacheKey);
    _cache.put(cacheKey, cacheArray);
  }
}

//..........cache 가져오기
//.....cache가 없는 경우 'getArrayCacheException' 발생
//.....cache 가져오는 경우 항상 try...catch 사용하기
function getArrayCache(cacheKey){
  var cached = _cache.get(cacheKey);
  
  if(cached){
    return JSON.parse(cached);
  }else{
    systemLog('Cache가 없습니다.');
    throw getArrayCacheException(cached);
  }
}

/******************** 로그 작성 함수  ********************/
function systemLog(msg){
  var timeStamp = getTime('SEPARATE');
  var dumpLogMsg = "["+ timeStamp +"] " + msg;
  
  _logSheet.appendRow([dumpLogMsg]);
  return ;
}

/******************** 시간  ********************/
//시간을 yyyymmddhhmnssMISS로 리턴
//type = 'NUMBER' || 'STRING' || 'SAPERATE'
function getTime(type, length){
  Date.prototype.timemaker = function(){
    var yyyy = this.getFullYear().toString();
    var mm = (this.getMonth() + 1).toString();
    var dd = this.getDate().toString();
    var hh = this.getHours().toString();
    var mn = this.getMinutes().toString();
    var ss = this.getSeconds().toString();
    var miss = this.getMilliseconds().toString(); //to string
    if(mm.length == 1){
      mm = '0' + mm;
    }
    if(dd.length == 1){
      dd = '0' + dd;
    }
    if(hh.length == 1){
      hh = '0' + hh;
    }
    if(mn.length == 1){
      mn = '0' + mn;
    }
    if(ss.length == 1){
      ss = '0' + ss;
    }
    if(miss.length != 4){
      var addCount = 4 - miss.length;
      for(var zz = 0; zz < addCount; zz++){
        miss = '0' + miss;
      }
    }
    
    if(type == 'SEPARATE'){
       return [yyyy,mm,dd].join('-') + " ["+ [hh,mn,ss,miss].join(":") + "]";
    }else{
      return [yyyy, mm, dd, hh, mn, ss, miss].join('');
    }
  }
  
  var d = new Date();
  
  if(!length){  
    var length = d.timemaker().length;
  }
  
  if(type == 'NUMBER'){
    return Number(d.timemaker().substring(0, length));
  }else if(type == 'STRING'|| type == 'SEPARATE'){
    return d.timemaker().substring(0, length);
  }
  //이외의 타입인 경우 뭐 리턴하지☆★☆★☆★☆★
}

//모듈 처리 추가해야 함☆★☆★☆★☆★☆★☆★☆★☆★☆★
//readEachSheet와 비슷한 시점에서 호출되어 비슷한 용도로 사용됨
//return은 array로
//[poc_clf, os_name, status, page_id, action_id, body]
function IndexHandler(){
  //자신을 실행시킨 트리거 삭제(default trigger 제외)
  if(_triggers[1]){
    ScriptApp.deleteTrigger(_triggers[0]);
  }
  
  var timestamp = getTime('NUMBER');
  
  var spreadsheetlistURL = 'https://docs.google.com/spreadsheets/d/18HiiJG-Utm6e-wXr2Ie_z_8TtlBwq3yPFLjf8v45F-Q/edit#gid=752895595';//page_id 리스트 URL
  var indexSpreadsheetURL = 'https://docs.google.com/spreadsheets/d/1Y8YaZL1WuNiUAjcSVi-7FQAxBSpv0myTeq3Kj1pwni0/edit#gid=0';//Index 정보를 담을 스프레드 시트 URL
  var errorSpreadSheetURL = 'https://docs.google.com/spreadsheets/d/13nQCDnHFWdYAIX5TDFdlD1kd61hPIvmidTDdEbbq7Cs/edit#gid=0' //error정보를 담을 스프레드 시트 URL
  
  //1. 정의서 리스트 불러오기
  var cacheKey = getTime('STRING').substring(0, 8) + "IndexlistCache";//YYYYMMDDIndexCache
  
  var spreadsheetlistMap = {
    spreadsheetInfo : [],
    index : '',
    cacheKey : ''
  }; //spreadsheetInfo, index, cacheKey
  
  //.....캐시에 정보가 없을 경우 정의서 리스트(URL)을 불러와 캐시에 저장
  try{
    spreadsheetlistMap = getArrayCache(cacheKey);
  }catch(e){
    spreadsheetlistMap.spreadsheetInfo = readSpreadsheetList(spreadsheetlistURL); //[정의서URL, 정의서 제목, 정의서 POC(시트명 기준)]
    spreadsheetlistMap.index = 0;
    spreadsheetlistMap.cacheKey = cacheKey;
  }
  systemLog(spreadsheetlistMap.spreadsheetInfo.length + "개의 정의서의 분석을 시작합니다.");
  
  //2. 불러온 정의서 리스트 for loop을 통해 index 생성
  var indexLength = spreadsheetlistMap.spreadsheetInfo.length;
  var startIndex = spreadsheetlistMap.index;
  
  systemLog('Index 생성을 시작합니다(' + startIndex + "/" + indexLength + ")");
  
  var resultObject = {
    processList : [],
    errorList : []
  };
  
  for(var i = startIndex; i < indexLength; i++){
    spreadsheetlistMap.index++;
    var spreadsheetlistArray = spreadsheetlistMap.spreadsheetInfo[i]; //[spreadsheet URL, spreadsheet title, spreadsheet POC]
    
    var sheetVerificationResult = makeIndex(spreadsheetlistArray[0], spreadsheetlistArray[2], timestamp); //obj
    
    if(sheetVerificationResult.processList){
      resultObject.processList = resultObject.processList.concat(sheetVerificationResult.processList);
    }else if(sheetVerificationResult.errorList){
      resultObject.errorList = resultObject.errorList.concat(sheetVerificationResult.errorList);
    }
    
    //루프를 돌 때마다 시간을 검사하여 최초 실행 시간으로부터 5분이 지난 경우 트리거를 2분 뒤에 세팅한 후 현재 트리거 종료
    var timeNOW = getTime('NUMBER');
    
    if(((timeNOW - timestamp) > 30 * 60 * 1000) || (i + 1 == indexLength)){
      //index정보와 오류 정보를 분기하여 저장
      if(resultObject.processList.length != 0){
        dumpSpreadsheet(indexSpreadsheetURL, cacheKey + "_index", resultObject.processList);
        systemLog(resultObject.processList.length + "개의 인덱스를 업데이트했습니다.");
      }
      if(resultObject.errorList.length != 0){
        dumpSpreadsheet(errorSpreadSheetURL, cacheKey + "_index_error", resultObject.errorList, true);
        systemLog(resultObject.errorList.length + "개의 오류를 업데이트했습니다.");
      }
      
      if(i + 1 != indexLength){
      spreadsheetlistMap.index = i + 1;
      setArrayCache(spreadsheetlistMap, cacheKey); //굳이 리스트 배열까지 다 저장할 필요 있나 싶지만.... cache IO를 줄이는 것이 낫기도 하고...
      
      //다음 트리거 세팅 후 현재 트리거 종료
      systemLog('트리거가 만료되어 Index 생성을 종료합니다. (' + i + "/" + indexLength + ")");
      setTrigger('IndexHandler', 2);
      return ;
      }else if(i + 1 == indexLength){ //-1 하는게 맞는가.....
        systemLog('index 생성이 완료되었습니다. (' + (i + 1) + "/" + indexLength + ")");
        
        //완료시 로그 생성 후 캐시 전부 삭제
        _cache.remove(cacheKey);
        
        //3. 피봇 테이블 생성
        makePivotTable();
        systemLog('피봇 테이블 생성이 완료되었습니다.');
        
        //4. spreadsheet검사 트리거 예약 후 현재 트리거 종료
        systemLog('SpreadsheetVerifyingHandler() 트리거를 생성한 후 현재 트리거를 종료합니다.');
        setTrigger('SpreadsheetVerifyingHandler', 2);
        return ;
      }
    }
  }
}

function makeIndex(spreadsheetURL, spreadsheetPOC, timestamp){
  var targetSpreadsheetURL = spreadsheetURL;
  var targetSpreadsheetPOC = spreadsheetPOC;
  var timeStamp = timestamp;
  
  var spreadsheet = SpreadsheetApp.openByUrl(targetSpreadsheetURL);
  var sheet = spreadsheet.getSheetByName(targetSpreadsheetPOC);
  
  var lastRow = sheet.getLastRow();
  var lastCol = sheet.getLastColumn();
  
  var content = sheet.getRange(1, 1, lastRow, lastCol).getValues();
  
  var ObjectForExamination = {
    PageAttribute : [], 
    BodyAttribute : [],
    SpreadsheetURL : targetSpreadsheetURL,
    SpreadsheetID : /spreadsheets\/d\/([a-zA-Z0-9-_]+)/.exec(targetSpreadsheetURL.toString())[1],
    TimeStamp : timeStamp
  } //{PageAttribute : [page_id, [poc_clf], [os_name]], BodyAttribute : [[state, action_id, [body1, body2, body3, ...]]], SpreadsheetURL : targetSpreadsheetURL,  SpreadsheetID : spreadsheetID, TimeStamp : timeStamp}
  
  /************************************** sheet information **************************************/
  //..........page_id, poc_clf, os_name
  //..........ObjectForExamination.PageAttribute array 정보 생성
  //page_id
  if(!content[0][0].match(/module/)){
    if(content[2][1] != ''){
      ObjectForExamination.PageAttribute[0] = content[2][1]; //page_id
    }else if(content[2][1] == ''){
      ObjectForExamination.PageAttribute[0] = 3; //page_id를 담은 행의 오류
    }
  }else if(content[0][0].match(/module/)){
    //모듈인 경우 해당 스프레드시트의 이름을 page_id에 넣음
    ObjectForExamination.PageAttribute[0] = spreadsheet.getName().substring(8);
  }
 
  //poc_clf, os_name
  var poc_clfRow = content[4];
  var poc_clfRowLength = poc_clfRow.length;
  
  if(poc_clfRowLength > 1){
    ObjectForExamination.PageAttribute[1] = [];
    ObjectForExamination.PageAttribute[2] = [];
    
    for(var k = 1; k < poc_clfRowLength; k++){
      if(content[4][k] == 'MW'){
          ObjectForExamination.PageAttribute[1].push('mw')
          ObjectForExamination.PageAttribute[2].push('');
      }else if(content[4][k] == 'APP(Android)'){
        ObjectForExamination.PageAttribute[1].push('app');
        ObjectForExamination.PageAttribute[2].push('Android');
      }else if(content[4][k] == 'APP(iOS)'){
        ObjectForExamination.PageAttribute[1].push('app');
        ObjectForExamination.PageAttribute[2].push('iOS');
      }else if(content[4][k] == 'PC'){
        ObjectForExamination.PageAttribute[1].push('pc');
        ObjectForExamination.PageAttribute[2].push('');
      }else{
        if([4][k+1]){
          if(content[4][k+1] == ''){
            break;
          }else{
            //POC구분 오류(MW, APP(iOS), APP(Android), PC <= 4개의 경우가 아니면 오류)
            ObjectForExamination.PageAttribute[1].push(5);
            ObjectForExamination.PageAttribute[2].push(5);
            break;
          }
        }
      }
    }
  }else{
    //POC구분 오류시 POC구분 오류 리턴
    //로그정의서 5행에 값이 완전 없는 경우 이 오류 객체를 리턴
    return {errorList : [[targetSpreadsheetURL],["POC구분 오류입니다."]]};
  }
  
  /************************************** action information **************************************/
  //..........status, action_id, body information
  //..........BodyAttribute 정보 생성
  
  //.....search body arrtibute
  var bodyStartPoint = 0; //body값이 시작되는 열
  var bodyDataStartRow = 0; //body 데이터 읽기가 시작되는 행
  
  //body인덱스 조정
  for(var i = 0; i < content[13].length; i++){
    if(content[13][i].match(/body/)){
      bodyStartPoint = i;
      bodyDataStartRow = 15;
      break;
    }
  }
  if(bodyStartPoint == 0){
    //14열이 아닌 부분에 body 기준점이 있는 issue때문에 추가된 코드
    //body 기준점이 없는 경우 그 다음 열을 검사함.
    for(i = 0; i< content[14].length; i++){
      if(typeof content[14][i] == 'string'){
        if(content[14][i].match(/body/)){
          bodyStartPoint = i;
          bodyDataStartRow = 16;
          break;
        }
      }
    }
    if(bodyStartPoint == 0){
      //body 검사 이전에 걸리는 오류이므로 배열검사 실행 불가능
      //body값 검사 없이 배열 생성 가능하지만 의미 없을 것 같아서 바로 오류메세지 리턴
      return {errorList : [[targetSpreadsheetURL],["  [system] body값의 기준점을 찾을 수 없습니다."]]}; //리턴 값 검토
    }
  }
  
  var counterForMapping = lastCol - bodyStartPoint; //body값이 있는 표 부분만 추출하기 위함
  var temp = [];
  var arrLength = 0;
  
  for(var j = bodyDataStartRow; j < lastRow; j++){
    //2차원 배열
    arrLength = ObjectForExamination.BodyAttribute.length;
    ObjectForExamination.BodyAttribute[arrLength] = [];
    temp[arrLength] = [];
        
    //actionID, state
    if(content[j][0] != ''){
      //state
      if(content[j][0] == '서비스중' || '삭제' || '추가' || '수정'){
        ObjectForExamination.BodyAttribute[arrLength][0] = content[j][0];
      }else{
        //state오류
        ObjectForExamination.BodyAttribute[arrLength][0] = j + 1;
      }
      
      //action_id
      //page_show, dom_content_loaded는 따로 핸들링
      if((content[j][2] != 'page_show') && (content[j][2] != 'dom_content_loaded')){
      //gesture, area, label을 합쳐 action_id 생성
        if((content[j][2] != '') && (content[j][3] != '') && (content[j][4] != '')){
          ObjectForExamination.BodyAttribute[arrLength][1] = content[j][2] + "." + content[j][3] + "." + content[j][4];
        }else{
          //gesture, area, label 중 하나라도 비어있으면 actionID 오류
          ObjectForExamination.BodyAttribute[arrLength][1] = j + 1; //(오류)actionID 비어있는 오류
        }
        //page_show와 dom_content_loaded는 따로 핸들링
      }else if((content[j][2] == 'page_show') || (content[j][2] == 'dom_content_loaded')){
        //합칠 필요 없이 page_show나 dom_content_loaded를 그대로 배열에 저장
        ObjectForExamination.BodyAttribute[arrLength][1] = content[j][2];
      }
    //빈 열 오류 방지를 위함
    }else if(content[j][0] == ''){
      if((content[j][2] != '') && (content[j][3] != '') && (content[j][4] != '')){
        //state 없는 경우
        ObjectForExamination.BodyAttribute[arrLength][0] = j + 1;
        ObjectForExamination.BodyAttribute[arrLength][1] = content[j][2] + "." + content[j][3] + "." + content[j][4];
      }else{
        //state도 없고 action_id도 없는 경우
        ObjectForExamination.BodyAttribute[arrLength][0] = j + 1;
        ObjectForExamination.BodyAttribute[arrLength][1] = j + 1;
      }
      //두 줄 이상 행에 내용이 없는 경우 
      if(content[j+1]){ 
        //[j+1]에 대한 검사를 하지 않고 [j+1][2]를 호출하면 오류 발생하므로 검사해야함.
        if(content[j+1][2] == ''){//content[j+1][2] == ''만 검증하게 됨.....
          ObjectForExamination.BodyAttribute.pop(); //이전 행도 내용이 없고 이후 행도 내용이 없으므로 이전 행 삭제, 앞으로의 행에도 내용이 없을 것이므로 break for-loop
          break;
        }
      }
    }
    //body 넣기
    content[j].slice(bodyStartPoint, lastCol).map(function(obj, idx){
      if(obj != ''){
        temp[arrLength].push("\""+obj+"\"");
      }
      if(idx == counterForMapping - 1){
        //body(JSON)
        ObjectForExamination.BodyAttribute[arrLength][2] = "{body:[" + temp[arrLength].join(',') + "]}";        
      }
      return obj;
    }).filter(function(x){
      //body array 사이에 빈 칸이 있는 경우 핸들링
      return x != '';
    });
  }
  //object 검사 추가
  return verificationObject(ObjectForExamination);
}

/************************************** verify object **************************************/
//객체를 for-loop를 통해 돌면서 검사
//[poc_clf, os_name, status, page_id, action_id, body]
function verificationObject(passedObject){
  var targetObj = passedObject;
  var SpreadSheetURL = targetObj.SpreadsheetURL;
  var errorMsgArray = []; //오류 메세지를 저장
  
  /************************** PageAttribute검사 **************************/
  //PageAttribute : [page_id, [poc_clf], [os_name]]
  var poc_clfLength = targetObj.PageAttribute[1].length;
  var pageAttributeArr=  targetObj.PageAttribute;

  //page_id 검사
  if(typeof pageAttributeArr[0] == 'number'){
    errorMsgArray.push(["        page_id 오류 : "+ pageAttributeArr[0] + "번 행"]);
  }
  //poc_clf, os_name 검사
  for(var tt = 0; tt < poc_clfLength; tt++){
    if(typeof pageAttributeArr[1][tt] == 'number'){
      errorMsgArray.push(["        poc_clf 오류 : "+ pageAttributeArr[1][tt] + "번 행"]); //poc는 행,열 컨트롤 가능할 것 같은뎅 (추가)
    }
  }
  
  /************************** BodyArrtibute검사 **************************/
  //BodyAttribute : [[state, action_id, body(JSON)]]
  var bodyLength = targetObj.BodyAttribute.length;
  var bodyArrtibuteArr = targetObj.BodyAttribute;
  var returnObject = {};
  
  for(var ww = 0; ww < bodyLength; ww++){
    if(typeof bodyArrtibuteArr[ww][0] == 'number'){
      errorMsgArray.push(["        status 오류: " + bodyArrtibuteArr[ww][0] + "번 행"]);
    }
    if(typeof bodyArrtibuteArr[ww][1] == 'number'){
      errorMsgArray.push(["        action_id 오류 : " + bodyArrtibuteArr[ww][1] + "번 행"]);
    }
  }
  
  if(errorMsgArray.length == 0){
    //오류가 없는 경우 함수를 호출하여 배열을 리턴
    if(pageAttributeArr[0] == 'module'){
      //모듈정의서인 경우 Object의 body만 리턴
      returnObject.processList = targetObj.BodyArrtibute;
      
      return returnObject;
    }else{
      //일반 정의서인 경우 전체 Object를 리턴
      return arrayGenerator(targetObj);
    }
  //오류가 있는 경우 에러 메세지를 출력하고 1을 리턴
  }else{
    errorMsgArray.unshift(["  [system] 오류 갯수 : " + errorMsgArray.length]);
    errorMsgArray.unshift(["--" + SpreadSheetURL + "시트의 오류 내용"]);
    
    returnObject.errorList = errorMsgArray;
    
    //오류가 있는 경우 오류 object을 리턴( {errorList : []} )
    return returnObject;
  }
}

/************************** Array를 생성하는 함수 **************************/
//검사 완료된 Object를 받아 배열을 생성하는 함수
//배열을 생성한 후 processList를 key로 갖는 Object를 리턴
//[poc_clf, os_name, status, page_id, action_id, body]
//passedObject = {PageAttribute : [page_id, [poc_clf], [os_name]], BodyAttribute : [[state, action_id, [body1, body2, ...]]], SpreadSheetURL : spreadSheetURL, SpreadsheetID : spreadsheetID, TimeStamp : timeStamp}
function arrayGenerator(passedObject){
  var pageAttribute = passedObject.PageAttribute;
  var bodyAttribute = passedObject.BodyAttribute;
  var spreadsheetID = passedObject.SpreadsheetID;
  var timeStamp = passedObject.TimeStamp;
  
  var returnArray = [];
  var returnObject = {};
  
  var pageID = pageAttribute[0];
  var poc_clf = pageAttribute[1];
  var os_name = pageAttribute[2];
  
  var pocCount = poc_clf.length;
  var bodyCount = bodyAttribute.length;
  var arrayLength = 0;
  
  for(var ee = 0; ee < pocCount; ee++){
    for(var bb = 0; bb < bodyCount; bb++){
      arrayLength = returnArray.length;
      returnArray[arrayLength] = [];
      
      //배열 생성
      returnArray[arrayLength][0] = spreadsheetID; //spreadsheetID
      returnArray[arrayLength][1] = poc_clf[ee]; //poc_clf
      returnArray[arrayLength][2] = os_name[ee]; //os_name
      returnArray[arrayLength][3] = bodyAttribute[bb][0]; //status
      returnArray[arrayLength][4] = pageID; //page_id
      returnArray[arrayLength][5] = bodyAttribute[bb][1]; //action_id
      returnArray[arrayLength] = returnArray[arrayLength].concat(bodyAttribute[bb][2]); //body
    }
  }
  returnObject.processList = returnArray;
  
  return returnObject;
}

/************************** 만들어진 Index로 pivot table을 생성하는 함수 **************************/
//.......... 시트 생성 등은 스크립트 class이용
//.......... 피봇테이블 생성은 google sheets API V4 이용
function makePivotTable(){
  systemLog('makePivotTable()함수를 시작합니다.');

  var indexSpreadsheetURL = 'https://docs.google.com/spreadsheets/d/1Y8YaZL1WuNiUAjcSVi-7FQAxBSpv0myTeq3Kj1pwni0/edit#gid=0'; //IndexSpreadsheet
  var indexSpreadsheet = SpreadsheetApp.openByUrl(indexSpreadsheetURL);
  var indexSpreadsheetID = indexSpreadsheet.getId();
  var indexSheets = indexSpreadsheet.getSheets();
  
  var indexSheetName = indexSheets[1].getName();
  var pivotSheetName = indexSheets[2].getName();
  
  //피봇 테이블이 없는 경우에만 피봇 테이블 생성
  if(!pivotSheetName.match(/pivot/) && indexSheetName.match(/_index/)){
    var pivotSourceDataSheet = indexSheets[1];
    
    var pivotSourceDataSheetId = pivotSourceDataSheet.getSheetId();
    var pivotSourceDataSheetLastCol = pivotSourceDataSheet.getLastColumn();
    var pivotSourceDataSheetLastRow = pivotSourceDataSheet.getLastRow();
    
    var destinationSheet = indexSpreadsheet.insertSheet(indexSheetName + "pivot", 2); //피봇 테이블을 넣을 시트
    var destinationSheetId = destinationSheet.getSheetId();
    
    //객체 중복되는 것 통합하기 @@@@@@@@@@@
    var requests = [{
      "updateCells" : {
        "rows" : {
          "values" : [
            {
              "pivotTable" : {
                "source" : {
                  "sheetId" : pivotSourceDataSheetId,
                  "startRowIndex" : 1,
                  "startColumnIndex" : 0,
                  "endRowIndex" : pivotSourceDataSheetLastRow,
                  "endColumnIndex" : pivotSourceDataSheetLastCol
                },
                "rows" : [
                  {
                    "sourceColumnOffset": 0,
                    "showTotals": false,
                    "sortOrder": "ASCENDING",
                    "valueBucket": {
                      "buckets": [
                        {
                          "stringValue": "West"
                        }
                      ]
                    }
                  },
                  {
                    "sourceColumnOffset": 4,
                    "showTotals": false,
                    "sortOrder": "ASCENDING",
                    "valueBucket": {
                      "buckets": [
                        {
                          "stringValue": "West"
                        }
                      ]
                    }
                  },
                  {
                    "sourceColumnOffset": 1,
                    "showTotals": false,
                    "sortOrder": "ASCENDING",
                    "valueBucket": {
                      "buckets": [
                        {
                          "stringValue": "West"
                        }
                      ]
                    }
                  },
                  {
                    "sourceColumnOffset": 2,
                    "showTotals": false,
                    "sortOrder": "ASCENDING",
                    "valueBucket": {
                      "buckets": [
                        {
                          "stringValue": "West"
                        }
                      ]
                    }
                  },
                  {
                    "sourceColumnOffset": 5,
                    "showTotals": false,
                    "sortOrder": "ASCENDING",
                    "valueBucket": {
                      "buckets": [
                        {
                          "stringValue": "West"
                        }
                      ]
                    }
                  },
                  {
                    "sourceColumnOffset": 6,
                    "showTotals": false,
                    "sortOrder": "ASCENDING",
                    "valueBucket": {
                      "buckets": [
                        {
                          "stringValue": "West"
                        }
                      ]
                    }
                  }
                ],
                "valueLayout": "HORIZONTAL"
              }
            }
          ]
        },
        "start" : {
          "sheetId" : destinationSheetId,
          "rowIndex" : 0,
          "columnIndex" : 0
        },
        "fields" : "pivotTable"
      }
    }];
    try{
      var response = Sheets.Spreadsheets.batchUpdate({'requests' : requests}, indexSpreadsheetID);
    }catch(e){
      systemLog(e);
    }
  }else{
    systemLog('해당 index data의 pivot table이 이미 존재합니다.');
  }
}

function SpreadsheetVerifyingHandler(){
  systemLog('SpreadsheetVerifyingHandler() 함수를 시작합니다.');
  ScriptApp.deleteTrigger(_triggers[1]);
  
  systemLog('SpreadsheetVerifyingHandler() 함수를 종료합니다.');
  return ;
}